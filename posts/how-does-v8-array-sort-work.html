<!DOCTYPE html><html lang="kr" class="__variable_fde3a9 __variable_5c2c97"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/3e7b7e3fd4560936-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/ff840cfebfb63b0c-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/a041bb0428bbbd07.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0b816f27d85c600a.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-6fa3b152797b4382.js"/><script src="/_next/static/chunks/f14ca715-e5f2eca283bbfe70.js" async=""></script><script src="/_next/static/chunks/465-78965795caee1f14.js" async=""></script><script src="/_next/static/chunks/main-app-6bc961e8a18df459.js" async=""></script><script src="/_next/static/chunks/618-c3b7cef9846f1d4b.js" async=""></script><script src="/_next/static/chunks/app/posts/page-ac2584213f378bee.js" async=""></script><script src="/_next/static/chunks/51534d8d-8939a30c6461dc02.js" async=""></script><script src="/_next/static/chunks/921-797225a54db5a0c0.js" async=""></script><script src="/_next/static/chunks/app/posts/%5Bslug%5D/page-077c683008f466a4.js" async=""></script><title>Create Next App</title><meta name="description" content="Generated by create next app"/><link rel="alternate" type="application/rss+xml" href="http://example.com/rss.xml"/><link rel="alternate" type="application/atom+xml" href="http://example.com/atom.xml"/><link rel="alternate" type="application/json" href="http://example.com/feed.json"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_fde3a9"><main class="min-h-screen max-w-[896px] desktop:p-24 p-6 text-gray-800"><img alt="hero image" loading="lazy" width="500" height="300" decoding="async" data-nimg="1" class="max-w-full w-full" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/fibonacci.jpg"/><h1 class="mt-7 mb-4 text-heading1 font-bold leading-normal" id="how-does-v8-array-sort-work">how-does-v8-array-sort-work</h1><span>2024-04-23</span>|<span>4<!-- --> mins</span><h1 class="mt-7 mb-4 text-heading1 font-bold leading-normal" id="v8의-arraysort는-어떻게-동작하는가"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#v8의-arraysort는-어떻게-동작하는가"><span class="icon icon-link"></span></a>V8의 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">Array.sort</code>는 어떻게 동작하는가?</h1>
<h2 class="mt-6 mb-3 text-heading2 font-semibold leading-normal" id="v8은-정렬-이전과-이후에-무엇을-하는가"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#v8은-정렬-이전과-이후에-무엇을-하는가"><span class="icon icon-link"></span></a>V8은 정렬 이전과 이후에 무엇을 하는가</h2>
<p class="font-light leading-normal mt-4 mb-2">V8은 한 개의 전처리 과정과 한 개의 후처리 과정을 거친다. 기본적인 아이디어는 다음과 같다.</p>
<blockquote class="my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">모든 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code> 값들을 임시 list에 모은 뒤, <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>가 아닌 값들을 정렬하고 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>를 뒤에 붙인다.</p>
</blockquote>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="전처리-과정"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#전처리-과정"><span class="icon icon-link"></span></a>전처리 과정</h2>
<p class="font-light leading-normal mt-4 mb-2">먼저 배열의 값들을 다음과 같이 분류한다.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>가 아닌 값들(비교 함수에 따라 정렬될 값)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>값들</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 빈칸, 즉 존재하지 않는 속성들</li>
</ol>
<p class="font-light leading-normal mt-4 mb-2">실제 정렬 알고리즘은 첫 번째 분류(undefined가 아닌 값)에만 적용되면 된다. 이를 위해서 V8은 다음과 같이 동작하는 전처리 과정을 가진다.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">배열을 순회하며<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">만약 원소가 hole이다. -&gt; 아무것도 하지 않는다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">만약 원소가 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>이다. -&gt; <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">numberOfUndefineds</code>의 값을 1 증가시킨다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">둘 다 아니라면 원소를 elements라는 임시 배열에 추가한다.</li>
</ol>
</li>
</ol>
<p class="font-light leading-normal mt-4 mb-2">이 작업이 이루어지면, 모든 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>가 아닌 값들은 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">elements</code>라는 임시 배열에 담기게 된다. <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>들은 개수만 알면 된다. 자바스크립트 sort의 명세에 따르면 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code> 들이 맨 끝에 정렬되어야한다. <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code> 값들은 실제로 유저가 제공한 비교 함수에 전달되지 않을 것이기 때문에 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>가 등장한 횟수만 새면 된다.</p>
<p class="font-light leading-normal mt-4 mb-2">다음으로 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">elements</code> 배열을 실제로 정렬한다. 글의 후반부 TimSort 섹션에서 자세한 내용을 다룬다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="후처리-과정"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#후처리-과정"><span class="icon icon-link"></span></a>후처리 과정</h2>
<p class="font-light leading-normal mt-4 mb-2">전처리를 거치고 얻은 정렬된 값들을 원본 배열 혹은 객체에 덮어써야 한다. 후처리 과정은 다시 세 단계로 구성된다.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">원본 객체의 앞부터 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">elements</code> 배열로 덮어쓴다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">그 뒤를 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">numberOfUndefineds</code> 값만큼 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">undefined</code>로 채운다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">나머지 값들은 삭제한다.</li>
</ol>
<p class="font-light leading-normal mt-4 mb-2">3번 과정은 정렬하려는 원본 객체에 hole이 포함된 경우에 필요하다. 3번을 하지 않으면 배열에 중복된 값이 생길 수 있다.</p>
<h2 class="mt-6 mb-3 text-heading2 font-semibold leading-normal" id="과거의-정렬-방식-quicksort"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#과거의-정렬-방식-quicksort"><span class="icon icon-link"></span></a>과거의 정렬 방식 (QuickSort)</h2>
<p class="font-light leading-normal mt-4 mb-2"><code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">Array.prototype.sort</code> 와 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">TypedArray.prototype.sort</code> 는 자바스크립트로 구현된 Quicksort 구현체에 의존했었다. 정렬 알고리즘 다소 단순하다: 기본적으로는 Quicksort를 하지만, 길이가 짧은 배열(length &lt; 10)에 대해서는 삽입 정렬을 사용한다. Quicksort 재귀 중 하위 배열의 길이가 10에 도달하면 삽입 정렬로 대체된다. 작은 배열에 대해서는 삽입 정렬이 더 효율적인데, 이는 Quicksort가 분할 이후 재귀적으로 두 번 호출되기 때문이다. 각 재귀 호출은 스택 프레임을 생성하고(그리고 제거하는) 오버헤드가 있다.</p>
<p class="font-light leading-normal mt-4 mb-2">Quicksort에서 적절한 pivot을 선택하는 것은 성능에 큰 영향을 준다. V8은 2가지 전략을 채택했다.</p>
<ul class="list-disc my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">피봇은 정렬될 배열의 첫 번째, 마지막 그리고 third-element 중 중앙값으로 선택되었다. 작은 배열의 경우 third-element는 단순히 배열의 중간 요소로 선정했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">큰 배열에선 표본을 추출하고, 표본을 정렬한 뒤, 정렬된 표본의 중앙값을 위 계산의 third-element로 사용했다.</li>
</ul>
<p class="font-light leading-normal mt-4 mb-2">퀵소트의 이점 중 하나는 in-place 정렬을 한다(혹은 그렇게 구현할 수 있다)는 것이다. 메모리 오버헤드는 큰 배열을 정렬할 때 표본을 저장하기 위한 작은 배열 할당과 log(n)의 스택 영역 할당뿐이다. 단점은 안정정렬이 아니라는 점과 QuickSort는 최악의 상황에 O(n^2)의 성능을 보인다는 점이다. 즉, 안정적이지 않았다.</p>
<h2 class="mt-6 mb-3 text-heading2 font-semibold leading-normal" id="현재의-정렬-방식-timsort"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#현재의-정렬-방식-timsort"><span class="icon icon-link"></span></a>현재의 정렬 방식 (Timsort)</h2>
<p class="font-light leading-normal mt-4 mb-2">2002년 파이썬에 탑재하기 위해 Tim Peter가 개발한 <strong class="font-medium">Timsort</strong>는 Merge sort와 Insertion sort를 기반으로 다양한 최적화 기법을 적용한 정렬이다. 현재는 Python, V8, Swift, Java SE 7 등 다양한 언어에서 채택되었다.</p>
<p class="font-light leading-normal mt-4 mb-2">기본적인 아이디어는 다음과 같다.</p>
<blockquote class="my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">연속적으로 정렬된 부분을 &quot;run&quot;이라고 하자.</p>
<p class="font-light leading-normal mt-4 mb-2">대부분의 현실 세계 데이터에는 이미 자연적으로 생긴 run들이 포함되어 있다.
이 run들을 이용하면 비교와 swap 비용을 줄일 수 있다.</p>
<p class="font-light leading-normal mt-4 mb-2">따라서 이 run들을 최대한 활용해 보자!</p>
</blockquote>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="run이란-무엇인가"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run이란-무엇인가"><span class="icon icon-link"></span></a>run이란 무엇인가?</h2>
<p class="font-light leading-normal mt-4 mb-2">run은 배열 내에 자연적으로 발생한 연속 정렬된 부분 수열이다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="random_array" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/random_array.jpg"/><em class="[img+&amp;]:block [img+&amp;]:text-center [img+&amp;]:text-gray-400 [img+&amp;]:font-thin [img+&amp;]:not-italic [img+&amp;]:text-sm [img+&amp;]:-translate-y-10">랜덤한 배열</em></p>
<p class="font-light leading-normal mt-4 mb-2">위와 같이 10개 원소를 가진 배열이 있다고 하자.
<img alt="run_example" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/run_example.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">위의 배열에서 run을 찾으면 (7,4) (9,3) (8,6,2) (10,1) (5)이 있다.</p>
<p class="font-light leading-normal mt-4 mb-2">run은 마지막 원소가 run이 되는 경우를 제외하고는 항상 길이가 2보다 길다.</p>
<p class="font-light leading-normal mt-4 mb-2">run은 증가하는 경우와 감소하는 경우 둘 다 상관없다. 배열을 증가하도록 정렬할 때 감소하는 run은 단순히 뒤집기만 하면 증가하는 run으로 만들 수 있기 때문이다.
run을 뒤집을 때는 양 끝값을 서로 swap하며 중앙으로 수렴하는 방식을 이용한다. 이때 stable을 지키기 위해 두 값을 비교해 한쪽이 엄격하게 작은 경우에만 swap한다.</p>
<pre class="font-monospace rounded-md language-js"><code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace language-js"><span class="code-line">funciton <span class="token function">reverseRun</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> middle <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>middle<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// arr는 어느 방향으로든 정렬이 되어있기 때문에 swap할 두 값의 값이 같다면</span>
</span><span class="code-line">      <span class="token comment">// 더 이상 swap을 할 필요가 없다.</span>
</span><span class="code-line">      <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="알고리즘-simple"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#알고리즘-simple"><span class="icon icon-link"></span></a>알고리즘 (simple)</h2>
<p class="font-light leading-normal mt-4 mb-2">알고리즘의 순서는 다음과 같다.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">minrun의 길이를 결정한다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">배열을 minrun을 기준으로 잘라 run을 만든다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">run을 병합한다. (1개의 배열이 될 때까지 반복한다)</li>
</ol>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="minrun의-크기를-결정하는-방식"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#minrun의-크기를-결정하는-방식"><span class="icon icon-link"></span></a>minrun의 크기를 결정하는 방식</h2>
<p class="font-light leading-normal mt-4 mb-2">run의 크기는 배열의 길이에 따라 유동적으로 결정된다.</p>
<p class="font-light leading-normal mt-4 mb-2">배열의 원소 수를 N이라고 하자. minrun이 될 수 있는 최대 값을 MAX_MINRUN이라고 하겠다.
N &lt; MAX_MINRUN이라면 minrun값은 N이 된다. 즉, run을 나누지 않는다. 대신 배열을 binary insertion sort한다. 앞서 언급했듯, 작은 배열에선 삽입정렬이 더 효율적이기 때문이다.</p>
<p class="font-light leading-normal mt-4 mb-2">Merge Sort에선 Merge(병합)해야하는 배열의 수가 2의 거듭제곱 (2^x)일때 가장 효율적이다.
그럴 수 없다면 2의 거듭제곱보다 조금 적을 때 효과적이다. 가장 최악은 2의 거듭제곱보다 조금 더 많은 경우이다.</p>
<p class="font-light leading-normal mt-4 mb-2">따라서 run의 수가 2의 거듭제곱이 될 수 있게 minrun의 길이를 결정하는 것이 좋다.</p>
<p class="font-light leading-normal mt-4 mb-2">예를 들어보자, N=2112, run의 길이는 32라고 하자.
run의 개수는 2112/32 = 66개가 나온다.</p>
<p class="font-light leading-normal mt-4 mb-2">66개의 run들을 병합하는 과정을 보자. 각 병합에는 최악의 경우 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">2 * (run의 길이) - 1</code> 번의 비교가 일어난다. 최악의 경우를 따져보자.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">32길이의 run을 33번 병합해야 한다. 63 * 33번의 비교가 발생했다. (64길이 33개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">64길이의 run을 16번 병합해야 한다. 127 * 16번의 비교가 발생했다. (128길이 16개, 64길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">128길이의 run과 64길이의 run을 병합한다. 128 + 64 - 1번의 비교가 발생했다. (128길이 15개, 192길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">128길이의 run을 7번 병합해야 한다. 255 * 7번의 비교가 발생했다. (256길이 7개, 192길이 1개, 128길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">192길이의 run 1개와 128길이의 run을 병합한다. 192 + 128 - 1번의 비교가 발생했다. (256길이 7개, 320길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">256길이의 run을 3번 병합해야 한다. 511 * 3번의 비교가 발생했다. (512길이 3개, 320길이 1개, 256길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">320길이의 run 1개와 256길이의 run을 병합한다. 320 + 256 - 1번의 비교가 발생했다. (512길이 3개, 576길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">512길이의 run을 1번 병합해야 한다. 1023번의 비교가 발생했다. (1024길이 1개, 576길이 1개, 512길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">576길이의 run 1개와 512길이의 run을 병합한다. 1088번의 비교가 발생했다. (1088길이 1개, 1024길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">1088길이의 run 1개와 1024길이의 run을 병합한다. 2111번의 비교가 발생했다. (병합 완료)</li>
</ol>
<p class="font-light leading-normal mt-4 mb-2">모두 <strong class="font-medium">12736</strong>번의 비교가 발생한다.</p>
<p class="font-light leading-normal mt-4 mb-2">하지만 run의 길이가 33이라면 어떨까?
run의 개수는 2112/33 = 64개가 나온다.</p>
<p class="font-light leading-normal mt-4 mb-2">같은 방식으로 병합을 진행해 보자.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">33길이의 run을 32번 병합해야 한다. 65 * 32번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">66길이의 run을 16번 병합해야 한다. 131 * 16번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">132길이의 run을 8번 병합해야 한다. 263 * 8번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">264길이의 run을 4번 병합해야 한다. 527 * 4번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">528길이의 run을 2번 병합해야 한다. 1055 * 2번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">1056길이의 run을 1번 병합해야 한다. 2111 * 1번의 비교가 발생했다.</li>
</ol>
<p class="font-light leading-normal mt-4 mb-2">모두 <strong class="font-medium">12609</strong>번의 비교가 발생한다.</p>
<p class="font-light leading-normal mt-4 mb-2">즉, run의 길이가 길어지더라도 run의 개수가 2의 거듭제곱과 일치하면 더 적은 비교가 발생한다.
run의 개수가 2의 거듭제곱보다 조금 많을 때 최악의 경우가 발생한다.</p>
<blockquote class="my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">run의 개수가 2의 거듭제곱과 같다면 효율적이다.
run의 개수가 2의 거듭제곱보다 조금 클 때 비효율적이다.</p>
</blockquote>
<p class="font-light leading-normal mt-4 mb-2">따라서 N / minrun이 2의 거듭제곱이 되는 minrun을 선택하고, 그런 minrun을 선택할 수 없다면 2의 거듭제곱에 가깝지만 엄격하게 2의 거듭제곱보다 작아지도록 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">MAX_MINRUN / 2 ~ MAX_MINRUN</code> 사이의 값 중에서 minrun을 선택한다.
예를 들어 MAX_MINRUN이 64라면 32 ~ 64중에 minrun을 선택한다.</p>
<p class="font-light leading-normal mt-4 mb-2">Timsort에선 실제로 MAX_MINRUN을 64로 잡는다. MAX_MINRUN이 8이면 함수 호출이 너무 많아 오버헤드가 더 크고 256이면 binary insertion sort가 느려 마찬가지로 영향을 주는 것을 확인했고, 최종적으로 32를 최적이라 생각했지만, 2112길이의 배열 예시처럼 2의 거듭제곱을 만들 수 있도록 32보다 큰 값을 허용하는 것이 좋다고 판단했기 때문이다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="insertion-sort를-이용하는-이유"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#insertion-sort를-이용하는-이유"><span class="icon icon-link"></span></a>Insertion sort를 이용하는 이유</h2>
<p class="font-light leading-normal mt-4 mb-2">Insertion sort(삽입 정렬)는 언뜻 보면 n^2의 시간복잡도를 가져 느리다고 생각할 수 있다. 하지만 앞서 Quicksort에서 설명했듯, 작은 길이 배열에 대해선 2번의 재귀 호출이 일어나는 Merge Sort보다 참조 지역성 원리의 수혜를 아주 잘 누리는 Insertion sort가 더 효율적이다.</p>
<p class="font-light leading-normal mt-4 mb-2">특히 배열이 이미 어느 정도 정렬되어 있으면 Insertion Sort는 더욱 효과적으로 된다. Insertion Sort는 최선의 경우 O(n)만큼의 복잡도를 갖기 때문이다.</p>
<p class="font-light leading-normal mt-4 mb-2">여기에 Binary Insertion sort를 사용하면 원소가 삽입될 위치를 O(nlogn)만에 찾도록 더 최적화할 수 있다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="minrun를-기준으로-run-만들기"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#minrun를-기준으로-run-만들기"><span class="icon icon-link"></span></a>minrun를 기준으로 run 만들기</h2>
<p class="font-light leading-normal mt-4 mb-2">주어진 배열의 길이로부터 minrun을 결정했다. 이제 minrun에 맞춰 배열을 자른다.
앞서 minrun은 32~64 사이의 값을 사용한다고 했지만, 이해를 위해 minrun의 값을 4로 잡자.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 1" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/find_minrun1.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">먼저 감소하는 부분수열 (7,4)를 찾았다. 하지만 minrun의 길이 4보다 짧기 때문에 뒤의 2개 수를 더 포함해 Binary Insertion Sort를 수행한다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 2" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/find_minrun2.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">이로써 minrun을 만족하는 첫 번째 run을 만들었다.
다음 run을 만들어보자.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 3" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/find_minrun3.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">마찬가지로 감소하는 길이 3인 부분 수열 (8,6,2)를 찾았다. 마지막 원소를 추가해 Binary Insertion Sort를 수행한다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 4" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/find_minrun4.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">2번째로 생성한 run은 minrun 길이는 만족했지만, run은 길수록 좋다. 따라서 뒤에 붙은 원소들을 포함해도 감소/증가하는 부분 수열임을 만족한다면 생성한 run에 추가한다.</p>
<p class="font-light leading-normal mt-4 mb-2">앞선 run에선 (10)을 포함할 수 없었다. 감소하는 run이었기 때문이다.
이번 run에선 뒤의 원소 (1)을 붙여도 여전히 감소하는 부분 수열을 만족하기 때문에 (1)을 run에 추가한다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 5" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/find_minrun5.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">마지막 원소는 합칠 수 있는 원소가 더 이상 없기 때문에 그 자체로 run이 된다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 6" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/find_minrun6.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">이렇게 해서 배열은 마지막 run을 제외하고 minrun과 같거나 더 긴 run들로 구성되었다.
이제 이들을 merge하면 된다.</p>
<p class="font-light leading-normal mt-4 mb-2">여기서 잠깐, 눈치 챘는지 모르겠지만, TimSort는 일반적인 MergeSort와 달리 재귀가 아닌 반복문을 이용해 구현한다. run을 생성하는 과정은 반복문이 이용된다. 이 덕분에 call stack overflow가 발생하지 않는 점도 최적화 포인트이다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="run을-병합하기"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run을-병합하기"><span class="icon icon-link"></span></a>run을 병합하기</h2>
<p class="font-light leading-normal mt-4 mb-2">Merge Sort는 병합할 때 비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.</p>
<p class="font-light leading-normal mt-4 mb-2">길이 m,h인 두 배열을 Merge할 때 최악의 경우 두 배열을 모두 순회하며 비교해야하기 때문에 m+h-1 만큼의 비용이 든다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="merge compare" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/merge_compare.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">5개의 원소를 병합하는 과정을 거칠 때를 예로 들어 보자. 앞의 배열부터 순서대로 병합을 진행한다고 하자. 이렇게 되면 큰 배열과 작은 배열을 연속적으로 병합하는 형태가 될 것이다.
이때 5개의 원소를 모두 병합하는데 들어가는 비용은 1 + 2 + 3 + 4 = 10이다.</p>
<p class="font-light leading-normal mt-4 mb-2">반면 작은 길이 배열을 먼저 병합하는 경우 모든 원소를 병합하는 비용은 1 + 1 + 2 + 4 = 8이다.</p>
<blockquote class="my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.</p>
</blockquote>
<p class="font-light leading-normal mt-4 mb-2">따라서 Timsort도 비슷한 길이의 배열을 merge할 수 있도록 다음의 방식으로 run들을 병합한다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="merge_criteria" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/merge_criteria.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">run을 생성할 때마다 Stack에 추가한다.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">스택의 상위 3개 run을 확인한다. 각각 A, B, C라고 하겠다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">각 run의 길이는 |A|,|B|,|C|라고 하겠다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">다음의 조건을 만족하지 않으면 B를 A와 C 중 짧은 쪽과 병합한다.<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">|B|가 |A|보다 길다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">|C|가 |A| + |B| 보다 길다.</li>
</ol>
</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">조건을 만족할 때까지 2를 반복한다.</li>
</ol>
<p class="font-light leading-normal mt-4 mb-2">이렇게 하면 결과적으로 다음과 같은 Stack을 얻을 수 있다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="fibonacci runstack" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/fibonacci.jpg"/></p>
<ul class="list-disc my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">A + B &lt; C</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">B + C &lt; D</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">C + D &lt; E</li>
</ul>
<p class="font-light leading-normal mt-4 mb-2">이 스택은 마치 피보나치의 수처럼 생겼다.</p>
<p class="font-light leading-normal mt-4 mb-2">이 스택을 위에서부터 순서대로 병합을 하면 비슷한 길이의 run들을 병합할 수 있다.
또한 스택에 원소들을 적게 유지할 수 있다. 피보나치의 수를 1부터 38까지 전부 더하면 1억을 좀 넘는 값이 나온다. 즉, 이러한 형태의 스택은 1억 개가 넘는 원소를 스택에 38개의 원소로 담고 있을 수 있다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="run-병합-최적화하기---메모리-최적화"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run-병합-최적화하기---메모리-최적화"><span class="icon icon-link"></span></a>run 병합 최적화하기 - 메모리 최적화</h2>
<p class="font-light leading-normal mt-4 mb-2">길이가 m,h인 두 run M,H를 병합할 때 우리는 (m+h)*2만큼의 메모리가 필요하다는 것을 알고 있다.
하지만 실은 간단한 최적화를 통해 2m + h (m &lt; h)만큼의 메모리를 사용하도록 개선할 수 있다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="merge optimization" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/merge_optimization.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">위와 같은 run H와 M이 있다고 하자. (m &lt; h)</p>
<p class="font-light leading-normal mt-4 mb-2">H 앞에 M을 복사해 붙여 넣는다.</p>
<p class="font-light leading-normal mt-4 mb-2"><img alt="merge optimization 2" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/merge_optimization2.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">이제 M의 시작 지점을 i, H의 시작 지점을 j로 두고 각 i와 j를 증가시키며 M의 복사본 + H 배열에 덮어쓰는 식으로 merge를 수행하면 된다.
i와 j 이전 인덱스는 확인할 필요가 없기 때문에 이러한 전략이 가능하다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="run-병합-최적화하기---검사할-필요가-없는-지점-찾기"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run-병합-최적화하기---검사할-필요가-없는-지점-찾기"><span class="icon icon-link"></span></a>run 병합 최적화하기 - 검사할 필요가 없는 지점 찾기</h2>
<p class="font-light leading-normal mt-4 mb-2"><img alt="merge optimization 3" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/merge_optimization3.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">M의 최댓값(즉 M의 마지막 원소)과 최솟값(M의 첫 번째 원소)가 H안의 어디에 위치하는지 확인하면 그 이후는 병합을 수행하지 않아도 된다.
위 이미지에서 M의 최댓값은 6이며 H[3] = 7보다 작다. 따라서 j가 k(=3)위치에 도착했다면 M[i] ~ M[M.length-1]까지의 값과 H[j] ~ H[H.length-1]값은 비교 없이 배열에 추가해 주면 된다.</p>
<p class="font-light leading-normal mt-4 mb-2">M의 최댓값, 최솟값이 H 안에서 어디 위치하는지는 Binary Search로 찾으면 된다.</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="run-병합-최적화하기---galloping-모드"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run-병합-최적화하기---galloping-모드"><span class="icon icon-link"></span></a>run 병합 최적화하기 - Galloping 모드</h2>
<p class="font-light leading-normal mt-4 mb-2"><img alt="galloping1" loading="lazy" width="704" height="300" decoding="async" data-nimg="1" class="object-cover mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/posts/how-does-v8-array-sort-work/images/galloping1.jpg"/></p>
<p class="font-light leading-normal mt-4 mb-2">앞선 예시에서 H를 좀 더 확장해 j와 k 사이에 많은 원소들이 있다고 치자. M[i] 원소를 삽입하기 전까지 H[j]에서부터 6을 발견할 때까지 j와 k 사이를 순회해야한다.
&quot;1개씩 모두 순회하지 않고 중간중간을 생략해 보자!&quot;가 Galloping의 아이디어이다.</p>
<p class="font-light leading-normal mt-4 mb-2">비교할 위치를 2^n씩 건너뛰며 검사한다. 예를 들어 처음 H[1]과 M[1]을 비교했다면 그 다음은 H[2], H[4], H[8]... 형식으로 비교할 index를 증가시킨다.
만약 H[8]과 비교해도 M[1]이 더 크다면 H[1] ~ H[8]은 M[1]보다 작은 값이니 H[1] ~ H[8]을 비교없이 merge하면 된다. 만약 M[1]이 H[16]보다 작다면 다시 H[8]로 돌아가 index를 1씩 증가시키며 원소를 비교한다.</p>
<p class="font-light leading-normal mt-4 mb-2">Galloping은 꽤 효율적으로 보이지만, Galloping이 비효율적인 구간도 있다.
일반적으로 H[0] ~ H[i]까지의 값이 M[0]보다 작을 때 선형적으로 i를 찾게되면 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">i+1</code>번의 비교가 발생하지만, Galloping을 이용하면 <code class="py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace">2 * floor(log(i)) + 2</code> 번의 비교가 필요하다.</p>
<p class="font-light leading-normal mt-4 mb-2">따라서 i가 6보다 크거나 같아지는 순간부터 Galloping이 효율적이게 된다. 따라서 선형 비교를 할지 Galloping을 할지 적절한 전략을 세우는 것이 필요하다. (선형비교가 3번 이상 일어나면 Galloping모드로 치환하는 등)</p>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="알고리즘-detail"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#알고리즘-detail"><span class="icon icon-link"></span></a>알고리즘 (detail)</h2>
<p class="font-light leading-normal mt-4 mb-2">다시 알고리즘을 세분화하여 다시 작성해 보자.</p>
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">minrun을 찾는다. (<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">listsort.txt</a>의 313줄 참고)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">배열의 앞부분부터 run을 생성한다.<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">minrun만큼 잘라 binary insertion sort를 수행한다. (처음 두 원소가 증가하는 방향이면 increase 정렬을, 감소하는 방향이면 decrease정렬을 수행한다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">그 뒤에 오는 원소들을 run에 합쳐도 증가/감소하는 방향을 유지할 수 있다면 run에 붙인다.</li>
</ol>
</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">생성한 run을 stack에 추가한다.<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">stack의 길이가 3보다 크다면, 스택 상위 3개의 원소(A,B,C)를 다음 조건에 맞는지 확인한다.</li>
</ol>
<ul class="list-disc my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">|B| &gt; |A|</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">[C| &gt; |A| + |B|</li>
</ul>
<ol class="list-decimal my-4" start="2">
<li class="text-paragraph font-light leading-normal py-1 ml-6">조건에 부합하지 않으면 B를 A와 C중 작은 쪽과 병합(merge)한다. 이를 조건에 부합할 때까지 반복한다.</li>
</ol>
</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">2번으로 돌아가 다음 run을 생성한다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 run 생성을 마치고 Stack에 run이 모두 채워졌다면 스택의 맨 위 원소부터 병합을 수행한다.</li>
</ol>
<h2 class="mt-5 mb-2 text-heading3 font-semibold leading-normal" id="timsort의-시간복잡도"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#timsort의-시간복잡도"><span class="icon icon-link"></span></a>Timsort의 시간복잡도</h2>
<p class="font-light leading-normal mt-4 mb-2">Insertion Sort의 최선 시간복잡도는 O(n), run을 생성한 결과 run이 1개만 나온 경우 (즉, 이미 정렬된 경우) O(n)의 시간복잡도를 가진다.
따라서 Timsort의 최선 시간복잡도는 O(n)이다.</p>
<p class="font-light leading-normal mt-4 mb-2">나머지는 사실상 Merge Sort가 진행되는 것과 같기 때문에 최악 시간복잡도와 평균 시간복잡도는 O(nlogn)이다.</p>
<h2 class="mt-6 mb-3 text-heading2 font-semibold leading-normal" id="v8의-torque"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#v8의-torque"><span class="icon icon-link"></span></a>V8의 Torque</h2>
<p class="font-light leading-normal mt-4 mb-2">이 부분은 간단하게만 언급하려고 한다. V8은 Torque라는 V8용 언어를 지원하며, 이 언어를 통해 V8의 JIT 수행에서 미리 컴파일 된 코드를 제공하도록 만들 수 있다.
V8은 Torque로 기존 js로 작성된 Array#sort를 다시 작성했으며, 이를 통해 속도를 더욱 끌어올렸다. 구체적인 설명은 <a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://v8.dev/blog/array-sort#introducing-v8-torque">Introducing V8 Torque</a>를 참고하면 된다.</p>
<h2 class="mt-6 mb-3 text-heading2 font-semibold leading-normal" id="참고"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#참고"><span class="icon icon-link"></span></a>참고</h2>
<p class="font-light leading-normal mt-4 mb-2"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://v8.dev/blog/array-sort">V8 Blog - array-sort</a>
<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://en.wikipedia.org/wiki/Timsort">위키피디아 - Timsort</a>
<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">cpython - Timsort</a>
<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://d2.naver.com/helloworld/0315536">D2 - Timsort에 대해 알아보자</a></p></main><script src="/_next/static/chunks/webpack-6fa3b152797b4382.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/3e7b7e3fd4560936-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/ff840cfebfb63b0c-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/css/a041bb0428bbbd07.css\",\"style\"]\n4:HL[\"/_next/static/css/0b816f27d85c600a.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"5:I[5726,[],\"\"]\n8:I[1699,[],\"\"]\na:I[2579,[],\"\"]\nb:I[9618,[\"618\",\"static/chunks/618-c3b7cef9846f1d4b.js\",\"991\",\"static/chunks/app/posts/page-ac2584213f378bee.js\"],\"\"]\nd:I[3141,[],\"\"]\n9:[\"slug\",\"how-does-v8-array-sort-work\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a041bb0428bbbd07.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"HKl7UytfaPA3mJjGrZ-cx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/how-does-v8-array-sort-work\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"how-does-v8-array-sort-work\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"how-does-v8-array-sort-work\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"how-does-v8-array-sort-work\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L6\",\"$L7\"],null],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0b816f27d85c600a.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"kr\",\"className\":\"__variable_fde3a9 __variable_5c2c97\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_fde3a9\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"h2\",null,{\"children\":\"Not Found\"}],[\"$\",\"p\",null,{\"children\":\"Could not find requested resource\"}],[\"$\",\"$Lb\",null,{\"href\":\"/\",\"children\":\"Return Home\"}]]}],\"notFoundStyles\":[],\"styles\":null}]}]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[5969,[\"822\",\"static/chunks/51534d8d-8939a30c6461dc02.js\",\"921\",\"static/chunks/921-797225a54db5a0c0.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-077c683008f466a4.js\"],\"Image\"]\n10:I[8487,[\"822\",\"static/chunks/51534d8d-8939a30c6461dc02.js\",\"921\",\"static/chunks/921-797225a54db5a0c0.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-077c683008f466a4.js\"],\"Anchor\"]\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"main\",null,{\"className\":\"min-h-screen max-w-[896px] desktop:p-24 p-6 text-gray-800\",\"children\":[[\"$\",\"$Lf\",null,{\"alt\":\"hero image\",\"src\":\"/posts/how-does-v8-array-sort-work/images/fibonacci.jpg\",\"className\":\"max-w-full w-full\",\"width\":\"500\",\"height\":\"300\"}],[\"$\",\"h1\",null,{\"className\":\"mt-7 mb-4 text-heading1 font-bold leading-normal\",\"id\":\"how-does-v8-array-sort-work\",\"children\":\"how-does-v8-array-sort-work\"}],[\"$\",\"span\",null,{\"children\":\"2024-04-23\"}],\"|\",[\"$\",\"span\",null,{\"children\":[4,\" mins\"]}],[[\"$\",\"h1\",null,{\"className\":\"mt-7 mb-4 text-heading1 font-bold leading-normal\",\"id\":\"v8의-arraysort는-어떻게-동작하는가\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#v8의-arraysort는-어떻게-동작하는가\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"V8의 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"Array.sort\"}],\"는 어떻게 동작하는가?\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-6 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"v8은-정렬-이전과-이후에-무엇을-하는가\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#v8은-정렬-이전과-이후에-무엇을-하는가\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"V8은 정렬 이전과 이후에 무엇을 하는가\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"V8은 한 개의 전처리 과정과 한 개의 후처리 과정을 거친다. 기본적인 아이디어는 다음과 같다.\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"모든 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\" 값들을 임시 list에 모은 뒤, \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"가 아닌 값들을 정렬하고 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"를 뒤에 붙인다.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"전처리-과정\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#전처리-과정\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"전처리 과정\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"먼저 배열의 값들을 다음과 같이 분류한다.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"모든 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"가 아닌 값들(비교 함수에 따라 정렬될 값)\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"모든 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"값들\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"모든 빈칸, 즉 존재하지 않는 속성들\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"실제 정렬 알고리즘은 첫 번째 분류(undefined가 아닌 값)에만 적용되면 된다. 이를 위해서 V8은 다음과 같이 동작하는 전처리 과정을 가진다.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"배열을 순회하며\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"만약 원소가 hole이다. -\u003e 아무것도 하지 않는다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"만약 원소가 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"이다. -\u003e \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"numberOfUndefineds\"}],\"의 값을 1 증가시킨다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"둘 다 아니라면 원소를 elements라는 임시 배열에 추가한다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"이 작업이 이루어지면, 모든 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"가 아닌 값들은 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"elements\"}],\"라는 임시 배열에 담기게 된다. \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"들은 개수만 알면 된다. 자바스크립트 sort의 명세에 따르면 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\" 들이 맨 끝에 정렬되어야한다. \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\" 값들은 실제로 유저가 제공한 비교 함수에 전달되지 않을 것이기 때문에 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"가 등장한 횟수만 새면 된다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"다음으로 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"elements\"}],\" 배열을 실제로 정렬한다. 글의 후반부 TimSort 섹션에서 자세한 내용을 다룬다.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"후처리-과정\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#후처리-과정\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"후처리 과정\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"전처리를 거치고 얻은 정렬된 값들을 원본 배열 혹은 객체에 덮어써야 한다. 후처리 과정은 다시 세 단계로 구성된다.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"원본 객체의 앞부터 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"elements\"}],\" 배열로 덮어쓴다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"그 뒤를 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"numberOfUndefineds\"}],\" 값만큼 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"undefined\"}],\"로 채운다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"나머지 값들은 삭제한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"3번 과정은 정렬하려는 원본 객체에 hole이 포함된 경우에 필요하다. 3번을 하지 않으면 배열에 중복된 값이 생길 수 있다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-6 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"과거의-정렬-방식-quicksort\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#과거의-정렬-방식-quicksort\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"과거의 정렬 방식 (QuickSort)\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"Array.prototype.sort\"}],\" 와 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"TypedArray.prototype.sort\"}],\" 는 자바스크립트로 구현된 Quicksort 구현체에 의존했었다. 정렬 알고리즘 다소 단순하다: 기본적으로는 Quicksort를 하지만, 길이가 짧은 배열(length \u003c 10)에 대해서는 삽입 정렬을 사용한다. Quicksort 재귀 중 하위 배열의 길이가 10에 도달하면 삽입 정렬로 대체된다. 작은 배열에 대해서는 삽입 정렬이 더 효율적인데, 이는 Quicksort가 분할 이후 재귀적으로 두 번 호출되기 때문이다. 각 재귀 호출은 스택 프레임을 생성하고(그리고 제거하는) 오버헤드가 있다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Quicksort에서 적절한 pivot을 선택하는 것은 성능에 큰 영향을 준다. V8은 2가지 전략을 채택했다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"피봇은 정렬될 배열의 첫 번째, 마지막 그리고 third-element 중 중앙값으로 선택되었다. 작은 배열의 경우 third-element는 단순히 배열의 중간 요소로 선정했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"큰 배열에선 표본을 추출하고, 표본을 정렬한 뒤, 정렬된 표본의 중앙값을 위 계산의 third-element로 사용했다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"퀵소트의 이점 중 하나는 in-place 정렬을 한다(혹은 그렇게 구현할 수 있다)는 것이다. 메모리 오버헤드는 큰 배열을 정렬할 때 표본을 저장하기 위한 작은 배열 할당과 log(n)의 스택 영역 할당뿐이다. 단점은 안정정렬이 아니라는 점과 QuickSort는 최악의 상황에 O(n^2)의 성능을 보인다는 점이다. 즉, 안정적이지 않았다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-6 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"현재의-정렬-방식-timsort\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#현재의-정렬-방식-timsort\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"현재의 정렬 방식 (Timsort)\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"2002년 파이썬에 탑재하기 위해 Tim Peter가 개발한 \",[\"$\",\"strong\",null,{\"className\":\"font-medium\",\"children\":\"Timsort\"}],\"는 Merge sort와 Insertion sort를 기반으로 다양한 최적화 기법을 적용한 정렬이다. 현재는 Python, V8, Swift, Java SE 7 등 다양한 언어에서 채택되었다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"기본적인 아이디어는 다음과 같다.\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"연속적으로 정렬된 부분을 \\\"run\\\"이라고 하자.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"대부분의 현실 세계 데이터에는 이미 자연적으로 생긴 run들이 포함되어 있다.\\n이 run들을 이용하면 비교와 swap 비용을 줄일 수 있다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 이 run들을 최대한 활용해 보자!\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run이란-무엇인가\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run이란-무엇인가\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run이란 무엇인가?\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run은 배열 내에 자연적으로 발생한 연속 정렬된 부분 수열이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/random_array.jpg\",\"alt\":\"random_array\",\"width\":704,\"height\":300}],[\"$\",\"em\",null,{\"className\":\"[img+\u0026]:block [img+\u0026]:text-center [img+\u0026]:text-gray-400 [img+\u0026]:font-thin [img+\u0026]:not-italic [img+\u0026]:text-sm [img+\u0026]:-translate-y-10\",\"children\":\"랜덤한 배열\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"위와 같이 10개 원소를 가진 배열이 있다고 하자.\\n\",[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/run_example.jpg\",\"alt\":\"run_example\",\"width\":704,\"height\":300}]]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"위의 배열에서 run을 찾으면 (7,4) (9,3) (8,6,2) (10,1) (5)이 있다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run은 마지막 원소가 run이 되는 경우를 제외하고는 항상 길이가 2보다 길다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run은 증가하는 경우와 감소하는 경우 둘 다 상관없다. 배열을 증가하도록 정렬할 때 감소하는 run은 단순히 뒤집기만 하면 증가하는 run으로 만들 수 있기 때문이다.\\nrun을 뒤집을 때는 양 끝값을 서로 swap하며 중앙으로 수렴하는 방식을 이용한다. 이때 stable을 지키기 위해 두 값을 비교해 한쪽이 엄격하게 작은 경우에만 swap한다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"font-monospace rounded-md language-js\",\"children\":[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace language-js\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"funciton \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"reverseRun\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token parameter\",\"children\":\"arr\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"const\"}],\" middle \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token known-class-name class-name\",\"children\":\"Math\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token method function property-access\",\"children\":\"floor\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"/\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"2\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \",[\"$\",\"span\",null,{\"className\":\"token keyword control-flow\",\"children\":\"for\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"let\"}],\" i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\"}],\"middle\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"++\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token keyword control-flow\",\"children\":\"if\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"===\"}],\" arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"      \",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// arr는 어느 방향으로든 정렬이 되어있기 때문에 swap할 두 값의 값이 같다면\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"      \",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 더 이상 swap을 할 필요가 없다.\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"      \",[\"$\",\"span\",null,{\"className\":\"token keyword control-flow\",\"children\":\"break\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"const\"}],\" temp \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" temp\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}]]}]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"알고리즘-simple\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#알고리즘-simple\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"알고리즘 (simple)\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"알고리즘의 순서는 다음과 같다.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"minrun의 길이를 결정한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"배열을 minrun을 기준으로 잘라 run을 만든다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"run을 병합한다. (1개의 배열이 될 때까지 반복한다)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"minrun의-크기를-결정하는-방식\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#minrun의-크기를-결정하는-방식\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"minrun의 크기를 결정하는 방식\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run의 크기는 배열의 길이에 따라 유동적으로 결정된다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"배열의 원소 수를 N이라고 하자. minrun이 될 수 있는 최대 값을 MAX_MINRUN이라고 하겠다.\\nN \u003c MAX_MINRUN이라면 minrun값은 N이 된다. 즉, run을 나누지 않는다. 대신 배열을 binary insertion sort한다. 앞서 언급했듯, 작은 배열에선 삽입정렬이 더 효율적이기 때문이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Merge Sort에선 Merge(병합)해야하는 배열의 수가 2의 거듭제곱 (2^x)일때 가장 효율적이다.\\n그럴 수 없다면 2의 거듭제곱보다 조금 적을 때 효과적이다. 가장 최악은 2의 거듭제곱보다 조금 더 많은 경우이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 run의 수가 2의 거듭제곱이 될 수 있게 minrun의 길이를 결정하는 것이 좋다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"예를 들어보자, N=2112, run의 길이는 32라고 하자.\\nrun의 개수는 2112/32 = 66개가 나온다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"66개의 run들을 병합하는 과정을 보자. 각 병합에는 최악의 경우 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"2 * (run의 길이) - 1\"}],\" 번의 비교가 일어난다. 최악의 경우를 따져보자.\"]}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"32길이의 run을 33번 병합해야 한다. 63 * 33번의 비교가 발생했다. (64길이 33개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"64길이의 run을 16번 병합해야 한다. 127 * 16번의 비교가 발생했다. (128길이 16개, 64길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"128길이의 run과 64길이의 run을 병합한다. 128 + 64 - 1번의 비교가 발생했다. (128길이 15개, 192길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"128길이의 run을 7번 병합해야 한다. 255 * 7번의 비교가 발생했다. (256길이 7개, 192길이 1개, 128길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"192길이의 run 1개와 128길이의 run을 병합한다. 192 + 128 - 1번의 비교가 발생했다. (256길이 7개, 320길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"256길이의 run을 3번 병합해야 한다. 511 * 3번의 비교가 발생했다. (512길이 3개, 320길이 1개, 256길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"320길이의 run 1개와 256길이의 run을 병합한다. 320 + 256 - 1번의 비교가 발생했다. (512길이 3개, 576길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"512길이의 run을 1번 병합해야 한다. 1023번의 비교가 발생했다. (1024길이 1개, 576길이 1개, 512길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"576길이의 run 1개와 512길이의 run을 병합한다. 1088번의 비교가 발생했다. (1088길이 1개, 1024길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"1088길이의 run 1개와 1024길이의 run을 병합한다. 2111번의 비교가 발생했다. (병합 완료)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"모두 \",[\"$\",\"strong\",null,{\"className\":\"font-medium\",\"children\":\"12736\"}],\"번의 비교가 발생한다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"하지만 run의 길이가 33이라면 어떨까?\\nrun의 개수는 2112/33 = 64개가 나온다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"같은 방식으로 병합을 진행해 보자.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"33길이의 run을 32번 병합해야 한다. 65 * 32번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"66길이의 run을 16번 병합해야 한다. 131 * 16번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"132길이의 run을 8번 병합해야 한다. 263 * 8번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"264길이의 run을 4번 병합해야 한다. 527 * 4번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"528길이의 run을 2번 병합해야 한다. 1055 * 2번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"1056길이의 run을 1번 병합해야 한다. 2111 * 1번의 비교가 발생했다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"모두 \",[\"$\",\"strong\",null,{\"className\":\"font-medium\",\"children\":\"12609\"}],\"번의 비교가 발생한다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"즉, run의 길이가 길어지더라도 run의 개수가 2의 거듭제곱과 일치하면 더 적은 비교가 발생한다.\\nrun의 개수가 2의 거듭제곱보다 조금 많을 때 최악의 경우가 발생한다.\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run의 개수가 2의 거듭제곱과 같다면 효율적이다.\\nrun의 개수가 2의 거듭제곱보다 조금 클 때 비효율적이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"따라서 N / minrun이 2의 거듭제곱이 되는 minrun을 선택하고, 그런 minrun을 선택할 수 없다면 2의 거듭제곱에 가깝지만 엄격하게 2의 거듭제곱보다 작아지도록 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"MAX_MINRUN / 2 ~ MAX_MINRUN\"}],\" 사이의 값 중에서 minrun을 선택한다.\\n예를 들어 MAX_MINRUN이 64라면 32 ~ 64중에 minrun을 선택한다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Timsort에선 실제로 MAX_MINRUN을 64로 잡는다. MAX_MINRUN이 8이면 함수 호출이 너무 많아 오버헤드가 더 크고 256이면 binary insertion sort가 느려 마찬가지로 영향을 주는 것을 확인했고, 최종적으로 32를 최적이라 생각했지만, 2112길이의 배열 예시처럼 2의 거듭제곱을 만들 수 있도록 32보다 큰 값을 허용하는 것이 좋다고 판단했기 때문이다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"insertion-sort를-이용하는-이유\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#insertion-sort를-이용하는-이유\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"Insertion sort를 이용하는 이유\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Insertion sort(삽입 정렬)는 언뜻 보면 n^2의 시간복잡도를 가져 느리다고 생각할 수 있다. 하지만 앞서 Quicksort에서 설명했듯, 작은 길이 배열에 대해선 2번의 재귀 호출이 일어나는 Merge Sort보다 참조 지역성 원리의 수혜를 아주 잘 누리는 Insertion sort가 더 효율적이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"특히 배열이 이미 어느 정도 정렬되어 있으면 Insertion Sort는 더욱 효과적으로 된다. Insertion Sort는 최선의 경우 O(n)만큼의 복잡도를 갖기 때문이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"여기에 Binary Insertion sort를 사용하면 원소가 삽입될 위치를 O(nlogn)만에 찾도록 더 최적화할 수 있다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"minrun를-기준으로-run-만들기\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#minrun를-기준으로-run-만들기\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"minrun를 기준으로 run 만들기\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"주어진 배열의 길이로부터 minrun을 결정했다. 이제 minrun에 맞춰 배열을 자른다.\\n앞서 minrun은 32~64 사이의 값을 사용한다고 했지만, 이해를 위해 minrun의 값을 4로 잡자.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/find_minrun1.jpg\",\"alt\":\"find minrun 1\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"먼저 감소하는 부분수열 (7,4)를 찾았다. 하지만 minrun의 길이 4보다 짧기 때문에 뒤의 2개 수를 더 포함해 Binary Insertion Sort를 수행한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/find_minrun2.jpg\",\"alt\":\"find minrun 2\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이로써 minrun을 만족하는 첫 번째 run을 만들었다.\\n다음 run을 만들어보자.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/find_minrun3.jpg\",\"alt\":\"find minrun 3\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"마찬가지로 감소하는 길이 3인 부분 수열 (8,6,2)를 찾았다. 마지막 원소를 추가해 Binary Insertion Sort를 수행한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/find_minrun4.jpg\",\"alt\":\"find minrun 4\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"2번째로 생성한 run은 minrun 길이는 만족했지만, run은 길수록 좋다. 따라서 뒤에 붙은 원소들을 포함해도 감소/증가하는 부분 수열임을 만족한다면 생성한 run에 추가한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"앞선 run에선 (10)을 포함할 수 없었다. 감소하는 run이었기 때문이다.\\n이번 run에선 뒤의 원소 (1)을 붙여도 여전히 감소하는 부분 수열을 만족하기 때문에 (1)을 run에 추가한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/find_minrun5.jpg\",\"alt\":\"find minrun 5\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"마지막 원소는 합칠 수 있는 원소가 더 이상 없기 때문에 그 자체로 run이 된다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/find_minrun6.jpg\",\"alt\":\"find minrun 6\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이렇게 해서 배열은 마지막 run을 제외하고 minrun과 같거나 더 긴 run들로 구성되었다.\\n이제 이들을 merge하면 된다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"여기서 잠깐, 눈치 챘는지 모르겠지만, TimSort는 일반적인 MergeSort와 달리 재귀가 아닌 반복문을 이용해 구현한다. run을 생성하는 과정은 반복문이 이용된다. 이 덕분에 call stack overflow가 발생하지 않는 점도 최적화 포인트이다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run을-병합하기\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run을-병합하기\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run을 병합하기\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Merge Sort는 병합할 때 비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"길이 m,h인 두 배열을 Merge할 때 최악의 경우 두 배열을 모두 순회하며 비교해야하기 때문에 m+h-1 만큼의 비용이 든다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/merge_compare.jpg\",\"alt\":\"merge compare\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"5개의 원소를 병합하는 과정을 거칠 때를 예로 들어 보자. 앞의 배열부터 순서대로 병합을 진행한다고 하자. 이렇게 되면 큰 배열과 작은 배열을 연속적으로 병합하는 형태가 될 것이다.\\n이때 5개의 원소를 모두 병합하는데 들어가는 비용은 1 + 2 + 3 + 4 = 10이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"반면 작은 길이 배열을 먼저 병합하는 경우 모든 원소를 병합하는 비용은 1 + 1 + 2 + 4 = 8이다.\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-green-500 p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 Timsort도 비슷한 길이의 배열을 merge할 수 있도록 다음의 방식으로 run들을 병합한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/merge_criteria.jpg\",\"alt\":\"merge_criteria\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run을 생성할 때마다 Stack에 추가한다.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"스택의 상위 3개 run을 확인한다. 각각 A, B, C라고 하겠다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"각 run의 길이는 |A|,|B|,|C|라고 하겠다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"다음의 조건을 만족하지 않으면 B를 A와 C 중 짧은 쪽과 병합한다.\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"|B|가 |A|보다 길다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"|C|가 |A| + |B| 보다 길다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"조건을 만족할 때까지 2를 반복한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이렇게 하면 결과적으로 다음과 같은 Stack을 얻을 수 있다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/fibonacci.jpg\",\"alt\":\"fibonacci runstack\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"A + B \u003c C\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"B + C \u003c D\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"C + D \u003c E\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이 스택은 마치 피보나치의 수처럼 생겼다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이 스택을 위에서부터 순서대로 병합을 하면 비슷한 길이의 run들을 병합할 수 있다.\\n또한 스택에 원소들을 적게 유지할 수 있다. 피보나치의 수를 1부터 38까지 전부 더하면 1억을 좀 넘는 값이 나온다. 즉, 이러한 형태의 스택은 1억 개가 넘는 원소를 스택에 38개의 원소로 담고 있을 수 있다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run-병합-최적화하기---메모리-최적화\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run-병합-최적화하기---메모리-최적화\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run 병합 최적화하기 - 메모리 최적화\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"길이가 m,h인 두 run M,H를 병합할 때 우리는 (m+h)*2만큼의 메모리가 필요하다는 것을 알고 있다.\\n하지만 실은 간단한 최적화를 통해 2m + h (m \u003c h)만큼의 메모리를 사용하도록 개선할 수 있다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/merge_optimization.jpg\",\"alt\":\"merge optimization\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"위와 같은 run H와 M이 있다고 하자. (m \u003c h)\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"H 앞에 M을 복사해 붙여 넣는다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/merge_optimization2.jpg\",\"alt\":\"merge optimization 2\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이제 M의 시작 지점을 i, H의 시작 지점을 j로 두고 각 i와 j를 증가시키며 M의 복사본 + H 배열에 덮어쓰는 식으로 merge를 수행하면 된다.\\ni와 j 이전 인덱스는 확인할 필요가 없기 때문에 이러한 전략이 가능하다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run-병합-최적화하기---검사할-필요가-없는-지점-찾기\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run-병합-최적화하기---검사할-필요가-없는-지점-찾기\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run 병합 최적화하기 - 검사할 필요가 없는 지점 찾기\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/merge_optimization3.jpg\",\"alt\":\"merge optimization 3\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"M의 최댓값(즉 M의 마지막 원소)과 최솟값(M의 첫 번째 원소)가 H안의 어디에 위치하는지 확인하면 그 이후는 병합을 수행하지 않아도 된다.\\n위 이미지에서 M의 최댓값은 6이며 H[3] = 7보다 작다. 따라서 j가 k(=3)위치에 도착했다면 M[i] ~ M[M.length-1]까지의 값과 H[j] ~ H[H.length-1]값은 비교 없이 배열에 추가해 주면 된다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"M의 최댓값, 최솟값이 H 안에서 어디 위치하는지는 Binary Search로 찾으면 된다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run-병합-최적화하기---galloping-모드\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run-병합-최적화하기---galloping-모드\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run 병합 최적화하기 - Galloping 모드\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"object-cover mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/posts/how-does-v8-array-sort-work/images/galloping1.jpg\",\"alt\":\"galloping1\",\"width\":704,\"height\":300}]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"앞선 예시에서 H를 좀 더 확장해 j와 k 사이에 많은 원소들이 있다고 치자. M[i] 원소를 삽입하기 전까지 H[j]에서부터 6을 발견할 때까지 j와 k 사이를 순회해야한다.\\n\\\"1개씩 모두 순회하지 않고 중간중간을 생략해 보자!\\\"가 Galloping의 아이디어이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"비교할 위치를 2^n씩 건너뛰며 검사한다. 예를 들어 처음 H[1]과 M[1]을 비교했다면 그 다음은 H[2], H[4], H[8]... 형식으로 비교할 index를 증가시킨다.\\n만약 H[8]과 비교해도 M[1]이 더 크다면 H[1] ~ H[8]은 M[1]보다 작은 값이니 H[1] ~ H[8]을 비교없이 merge하면 된다. 만약 M[1]이 H[16]보다 작다면 다시 H[8]로 돌아가 index를 1씩 증가시키며 원소를 비교한다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"Galloping은 꽤 효율적으로 보이지만, Galloping이 비효율적인 구간도 있다.\\n일반적으로 H[0] ~ H[i]까지의 값이 M[0]보다 작을 때 선형적으로 i를 찾게되면 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"i+1\"}],\"번의 비교가 발생하지만, Galloping을 이용하면 \",[\"$\",\"code\",null,{\"className\":\"py-1 px-2 rounded-md bg-gray-200 text-red-400 font-monospace\",\"children\":\"2 * floor(log(i)) + 2\"}],\" 번의 비교가 필요하다.\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 i가 6보다 크거나 같아지는 순간부터 Galloping이 효율적이게 된다. 따라서 선형 비교를 할지 Galloping을 할지 적절한 전략을 세우는 것이 필요하다. (선형비교가 3번 이상 일어나면 Galloping모드로 치환하는 등)\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"알고리즘-detail\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#알고리즘-detail\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"알고리즘 (detail)\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"다시 알고리즘을 세분화하여 다시 작성해 보자.\"}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"minrun을 찾는다. (\",[\"$\",\"$L10\",null,{\"href\":\"https://github.com/python/cpython/blob/main/Objects/listsort.txt\",\"children\":\"listsort.txt\"}],\"의 313줄 참고)\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"배열의 앞부분부터 run을 생성한다.\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"minrun만큼 잘라 binary insertion sort를 수행한다. (처음 두 원소가 증가하는 방향이면 increase 정렬을, 감소하는 방향이면 decrease정렬을 수행한다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"그 뒤에 오는 원소들을 run에 합쳐도 증가/감소하는 방향을 유지할 수 있다면 run에 붙인다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"생성한 run을 stack에 추가한다.\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"stack의 길이가 3보다 크다면, 스택 상위 3개의 원소(A,B,C)를 다음 조건에 맞는지 확인한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"|B| \u003e |A|\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"[C| \u003e |A| + |B|\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"조건에 부합하지 않으면 B를 A와 C중 작은 쪽과 병합(merge)한다. 이를 조건에 부합할 때까지 반복한다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"2번으로 돌아가 다음 run을 생성한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"모든 run 생성을 마치고 Stack에 run이 모두 채워졌다면 스택의 맨 위 원소부터 병합을 수행한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-5 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"timsort의-시간복잡도\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#timsort의-시간복잡도\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"Timsort의 시간복잡도\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Insertion Sort의 최선 시간복잡도는 O(n), run을 생성한 결과 run이 1개만 나온 경우 (즉, 이미 정렬된 경우) O(n)의 시간복잡도를 가진다.\\n따라서 Timsort의 최선 시간복잡도는 O(n)이다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"나머지는 사실상 Merge Sort가 진행되는 것과 같기 때문에 최악 시간복잡도와 평균 시간복잡도는 O(nlogn)이다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-6 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"v8의-torque\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#v8의-torque\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"V8의 Torque\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"이 부분은 간단하게만 언급하려고 한다. V8은 Torque라는 V8용 언어를 지원하며, 이 언어를 통해 V8의 JIT 수행에서 미리 컴파일 된 코드를 제공하도록 만들 수 있다.\\nV8은 Torque로 기존 js로 작성된 Array#sort를 다시 작성했으며, 이를 통해 속도를 더욱 끌어올렸다. 구체적인 설명은 \",[\"$\",\"$L10\",null,{\"href\":\"https://v8.dev/blog/array-sort#introducing-v8-torque\",\"children\":\"Introducing V8 Torque\"}],\"를 참고하면 된다.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"className\":\"mt-6 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"참고\",\"children\":[[\"$\",\"$L10\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#참고\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"참고\"]}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[[\"$\",\"$L10\",null,{\"href\":\"https://v8.dev/blog/array-sort\",\"children\":\"V8 Blog - array-sort\"}],\"\\n\",[\"$\",\"$L10\",null,{\"href\":\"https://en.wikipedia.org/wiki/Timsort\",\"children\":\"위키피디아 - Timsort\"}],\"\\n\",[\"$\",\"$L10\",null,{\"href\":\"https://github.com/python/cpython/blob/main/Objects/listsort.txt\",\"children\":\"cpython - Timsort\"}],\"\\n\",[\"$\",\"$L10\",null,{\"href\":\"https://d2.naver.com/helloworld/0315536\",\"children\":\"D2 - Timsort에 대해 알아보자\"}]]}]]]}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"link\",\"4\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"http://example.com/rss.xml\"}],[\"$\",\"link\",\"5\",{\"rel\":\"alternate\",\"type\":\"application/atom+xml\",\"href\":\"http://example.com/atom.xml\"}],[\"$\",\"link\",\"6\",{\"rel\":\"alternate\",\"type\":\"application/json\",\"href\":\"http://example.com/feed.json\"}],[\"$\",\"link\",\"7\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"8\",{\"name\":\"next-size-adjust\"}]]\n6:null\n"])</script></body></html>