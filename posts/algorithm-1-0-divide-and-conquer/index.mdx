---
title: algorithm-1-0-divide-and-conquer
created: 2024-03-31T12:40:51.204Z
modified: 2024-03-31T12:50:16.610Z
slug: algorithm-1-0-divide-and-conquer
---


# 1. 분할정복

분할정복은 문제 풀이의 정석적인 방법중 하나다. 이름에서 알 수 있듯, 분할정복의 논지는 다음과 같다.

> 큰 문제를 풀 수 있는 작은 문제 여럿으로 분리해 각개격파한다.

```ts
function bigProblem(input) {
  smallProblem();
  smallProblem();
  // ...
  return solution;
}
```

## 분할정복을 사용할 수 없는 경우

> 부분의 합이 전체보다 큰 경우

## 분할정복 설계 방법

문제를 분할정복으로 풀고자 한다면 다음과 같은 순서로 설계할 수 있다.

1. 문제의 입력을 하나 이상의 작은 입력으로 분할한다.
2. 작은 입력을 각각 푼다.
3. 필요에 따라 분할하여 푼 내용을 합쳐 답을 만들어낸다.

## 분할정복을 이용하는 대표적인 알고리즘

1. 이분 탐색(binary search)
2. 병합정렬(merge sort)
3. 퀵정렬(quick sort)
4. 쉬트라쎈 행렬곱셈

## 짧은 예제 

### 큰 정수 계산하기

초등학생 때 배웠던 인수분해를 통해 큰 수를 작은 수로 분할해 계산할 수 있다.

```
1234 * 5678 
= (12 * 100 + 34) * (56 * 100 + 78) 
= `12*56*10000 + (12*78 + 34*56)*100 + 34*78

// 문제가 작은 수 곱하기 3개와 숫자 더하기 문제로 쪼개졌다.
```

### 하노이의 탑

![하노이의 탑](./images/hanoi.png)
출처: https://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91

하노이의 탑을 완성하기 위해 원판을 옮기는 작업의 최소 수를 `T(n), n=원판의 수`라고 하자
하노이의 탑은 다음과 같이 문제를 쪼갤 수 있다. T(6)을 풀어보자

1. 가장 큰 원판 위에 올라간 원판을 모두 2번 기둥으로 옮긴다. -> T(5)
2. 가장 큰 원판을 3번 기둥으로 옮긴다. -> 1
3. 2번 기둥의 원판을 3번 기둥으로 옮긴다. -> T(5)

`T(6) = 2*T(5)+1`이다.
즉 원판을 옮겨야하는 수는 하나 적은 수의 원판을 옮기는 문제로 치환된다.

## 분할정복의 최적화

작은 문제로 쪼갰을 때, 이미 푼 작은 문제를 다시 마주했다면 그 작은 문제는 다시 풀 필요가 없다. 즉, 캐싱으로 최적화가 가능하다.

### 피보나치 수

> 1 1 2 3 5 8 13 21 34 ...

n번째 피보나치 수를 `T(n)`이라고 하자.

> T(n) = T(n-1) + T(n-2)

피보나치 수를 재귀식으로 풀어가다보면 T(1), T(2) 등 작은 문제를 여러번 계산한다는 것을 알 수 있다.

```
T(5) = T(4) + T(3)
T(4) = T(3) + T(2)
T(3) = T(2) + T(1)

T(5) = T(2) + T(1) + T(2) + T(2) + T(1)
= T(1)*2 + T(2)*3
```
